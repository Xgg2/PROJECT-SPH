# app

## Project setup
```
npm install
```

### Compiles and hot-reloads for development
```
npm run serve
```

### Compiles and minifies for production
```
npm run build
```

### Lints and fixes files
```
npm run lint
```

### Customize configuration
See [Configuration Reference](https://cli.vuejs.org/config/).

注意使用npm run serve 运行脚手架的时候，需要将项目切换到对应的脚手架文件，在这里是app文件，否则会报错。
###3.项目路由分析
vue-router
路由组件：
home首页路由组件，search路由组件 ，login路由组件，Register注册路由组件 ，都是中间部分（共用header，footer（首页，搜索页有，登录页没有））
非路由组件：Header组件，Footer组件

4.完成非路由组件Header+footer
在项目中，主要以业务和逻辑为主
项目中开发的步骤逻辑：
            （1）书写静态页面（html,css）
            （2）拆分组件  （普通的组件，路由组件）
            （3）获取服务器数据动态展示（请求）
            （4）完成相应的动态业务逻辑

注意1：创建组件的时候，组件的结构+组件的样式+图片资源
注意2：项目采用less样式，浏览器不识别less样式，需要通过less、less-loader进行处理less，把less样式转变为css样式浏览器才可以识别。
注意3：让组件识别less样式，组件中style标签的lang属性添加less的属性值
npx cnpm i  --save less less-loader**  通过淘宝镜像安装处理css中less样式的less-loader

###4.1 使用组件（非路由组件）
创建组件  引入组件  注册组件  使用组件


5.路由组件的搭建
home首页路由组件，search路由组件 ，login路由组件，Register注册路由组件

5.1router文件中配置路由    注意安装的vue-router的版本
5.2总结 
路由组件与非路由组件的区别
1：components文件中放置普通组件，pages文件中放置路由组件
2：在router文件中进行对应的路由配置
3：在main.js中配置注册完路由器后，路由组件身上都会由$route和$router
$route （每个路由的对应信息，query  params..）
$router（路由器 编程式路由导航push/replace..）

###5.3路由的跳转
（1）router-link标签 配合to
（2）任意标签 ，通过事件回调，里面写$router.push/replace方法 （方法中是一个对象，可以实现跳转的路由路径，传递参数，是否有浏览历史记录）
    也就是我们说的编程式路由导航

###6.footer组件的显示与隐藏
在Home,Search中显示Footer组件
在Login ,register组件显示的时候，就会隐藏或消失  v-show （显示与隐藏）  v-if （删除）
6.1根据组件身上的$route.path获取当前的路由路径，通过这个判断Footer组件的显示与隐藏 （简单，但是当路由组件过多的时候就会非常的麻烦）
    也可以通过当前的路由元信息meta，进行判断显示与隐藏的
        注意：虽然每个路由组件都会有自己对应的$route,但是每切换一次路由组件，在当前时间点对应的路由$route只有一个（当前url路径上的）
            根据当前的路由组件的$route的meta路由元信息进行判断。

技术点：路由配置的元信息meta ,v-show ,

###8)路由的跳转
8.1路由跳转

技术点：路由的配置 ，router-link标签+to属性，及router-view标签  

### 9)路由传参相关的面试题
1、路由传参（对象写法）path可以和params一起使用?  答：不可以（会报错），使用params传参必须结合路由name名使用
2、如何指定params参数可传可不传？url路径会出现问题，对应跳转的路由组件的路由会消失    path:'/search/:keyword?   ，占位后面加个?表示params参数可传可不传？ url路径会出现问题，对应跳转的路由组件的路由会消失  。
3、params参数可传可不传，但是如果传递是空串，如何解决？  传的是空串 我们直接使用 '' || undefined  ，前者空串为false，逻辑或表达式的的值就是后者undefined。或直接this.keyword || undefined
4、路由组件能不能传递props数据？可以子啊对应路由组件配置对象中配置传递  对想法，布尔值法，函数法


### 重写路由器$router的push和replace方法
10) 在我们使用编程式路由导航的时候，如果多次将参数传递给某个组件时（就会出现Uncaught (in promise) NavigationDuplicated: ）这
样的错误，而声明式导航没有，声明式导航vue-router底层已经写好处理了。
在我们调用路由组件$route.push()时，会返回一个promise对象，使用.catch()处理的话治标不治本
    
this.$router.push
this表示当前路由组件，也就是VueComponent的实例对象vc
this.$router就是当我们在vm配置项中注册router时，vm以及vc身上都会有$router路由器，$router就是VueRouter构造函数的实例
$router.push方法就是$router实例沿着原型链向上查找，找到VueRouter的prototype身上的方法

我们调用了新的push方法，push方法中通过call方法调用原来的push方法originPush，并将originPush方法的this指向修改为调用新push的VueRouter的实例对象$router，给旧的push方法传入跳转的路径以及传递的数据（并判断在路由组件中通过$router调用push 时是否传递了成功与失败回调）有就实行那里传递的，没有就执行我们处理NavigationDuplicated问题的那个回调()=>{}

### Home模块组件拆分
--静态页面完成
--静态组件拆分
--获取服务器数据展示
--js动态业务完成

三级联动组件完成
--- 由于三级联动在Home,Search,Detail出现了，把三级联动注册为全局组件Vue.component('组件名',创建的名)，只需注册一次，就可以在项目任何位置使用
注册全局组件
```vue
<div id="root1">我是模板1<Hello></Hello></div>
<div id="root2">我是模板2<Hello></Hello></div>

//创建组件
let hello=Vue.extend({
    template:`<div><p>{{msg}}</p></div>`,
    data(){
        return:msg:'hello'
    }
    });
//将创建的hello组件进行注册（全局）
Vue.component('Hello',hello);
let vm1=new Vue({
el:'#root1',
data:{}
});

let vm2=new Vue({
el:'#root2',
data:{}
});
```

技术点：注册全局组件
### 剩余静态组件的拆分

这些组件都在首页Home路由组件中
拆分结构，样式，图片，引入，注册组件，在Home组件中使用


### Postman接口测试
经过Postman接口测试工具测试http://39.98.123.211:8510/api/product/getBaseCategoryList接口没有问题，可以得到数据
"code": 200,
"message": "成功",
"data": [
{
在项目所有的接口前缀都有/api字样

### axios请求的二次封装 
axios是基于XMLHttpRequest构造函数页面无刷新发送请求的二次封装
向服务器发送请求，拿数据，页面渲染。
为什么要进行axios的二次封装？
请求拦截器 ：可以在发送请求之前处理一些业务  axios实例.interceptors.request.use(()=>{})
响应拦截器：当服务器数据返回以后，可以处理一些数据   axios实例.interceptors.response.use(()=>{})

在项目中一般会有一个api文件夹，放axios请求的的

new Error('faile')  //Error构造函数的基本
Error: faile
    at <anonymous>:1:1
技术点：axios  基本使用，延时时间，请求和响应的拦截器

### 接口统一管理
项目很小，（1-2个组件）就可以直接在组件的生命周期中发请求拿数据。
项目很大：如果哪一天接口地址变了，需要一个一个请求的改接口（几十个接口就很麻烦）

let req=axios.create() ;会创建一个axios请求实例对象req，Axios用于在web浏览器或Node.js应用程序上发送http请求，您可以使用自定义配置（例如自定义基本 URL、默认标头、超时等）创建 Axios 库的新实例。
```
//创建axios实例以后，可以这样使用 处理
req.get('url').then(response=>{}).catch(err=>{})
```
跨域 ：同源策略，协议，域名，端口号相同，违背同源策略就是跨域
脚手架代理：在文件vue.config.js文件中，配置devServer:{proxy:'请求的地址'}  一个或devServer:{proxy:{'/api1':{target:'请求的地址',pathRewrite{}}}}多个代理
控制是否走代理/api1,请求本机资源时，在地址的最前面写个/api1名字任意，控制请求是否走代理，走的话，会在pathRewrite中把控制是否走代理的类路径替换掉
```
//我们通过一个函数返回一个axios已经配置好路径和请求方式的实例，调用函数的时候就是发送请求拿数据直接可以使用.then以及,catch进行处理
export const reqCategoryList =()=> axs({url:'/api1/product/getBaseCategoryList',method:'GET'});//这里调用会返回一个axios请求可以使用.then和.catch进行处理 
```

### 进度条的管理 nprogress 插件

就是在这里当我们发送请求的时候,顶部就会有一个进度条,服务器响应返回数据的时候,进度条就会消失
使用进度条插件,还需要引入进度条的样式

进度条插件的基本使用
--npm i --save nprogress 安装 
--nprogress.start();进度条开始  一般放在请求拦截器中,当开始发送请求的时候,进度条开始出现
--nprogress.done();进度条结束   一般放在响应拦截器中,当服务器响应成功的时候,结束进度条
--也可在nprogress.css中修改进度条的样式

### vuex状态(数据)管理插件(库)
集中式管理数据(状态),$store.dispatch() 联系actions对象,$store.commit() 联系mutations对象,mutations对象可以直接访问(操作)到state对象中的数据 ,组件拿数据$store.state.xxx ,或$store.getters.xxx 。
Vuex用于集中式管理项目中共用的数据
切记，并不是所有的项目都用到vuex，如果项目很小就不需要用vuex，如果项目很大，组件多，数据多，数据维护很费劲，就需要vuex
安装vuex,在这里Vue2脚手架，安装vuex@3版本

如果组件很多，请求的接口很多，我们需要对vuex进行模块化的存储数据 ，大致就是每组件（或多个）一个小仓库（包含actions,mutations,state,getters）,最后都在Vuex.Store({})构造函数实例对象store配置中注册
没有模块式开发，数据都在一起，容易混乱

### 动态展示三级联动
向服务器发送请求，拿数据，页面动态渲染
在三级联动组件TypeNav一挂载完毕就发请求，拿数据
v-for遍历三级列表数据，动态展示
spList:[
//一级列表
    {
        id:1,
        child:[
    //二级列表
            {
            id:01,
                child:[
            //三级列表
                {
                    id:002,
                    name:'',
            },
                {},
                {},
                {}
            ]   
        },
            {},
            {},
            {},
        ]
    },
    {},
    {},
    {}
]

### 鼠标悬停一级菜单（加背景样式）
css
通过v-for中的index，使用@mouseenter事件回调函数接收index,把index传到data中，使用  :class="cu:index=sjIndex",动态添加class样式v-for中的任意一个index已经存在data的sjIndex中，就表示已经触发了移入事件，就给一个class样式名出现背景颜色，移出利用共同的父元素，使用事件委托，@mouseleave事件，
事件委托：它允许我们使用一个共同的父元素来处理子元素的事件，而不需要给每个子元素都绑定事件处理器。
使用事件委托的原理是利用事件的冒泡机制，即当一个事件被触发时，它会在父元素和祖先元素之间依次传递，直到到达文档根节点。因此，我们可以把事件处理程序绑定在父元素上，然后根据事件的目标元素（即实际触发事件的元素）来确定要执行哪些操作，当用户点击任何一个按钮时，事件会一直冒泡到父元素<div>，然后由父元素上的事件处理程序来处理。在处理程序中，我们可以使用event.target属性来获取实际触发事件的按钮元素，然后根据需要进行操作


### 用js控制二三级菜单联动的显示与隐藏

通过:style="{display:index===sjIndex ? 'block' : 'none'}" ,动态添加样式，当v-for中的index在sjIndex中有了的时候，表示触发了移入事件回调，就需要展示对应的样式了， 有? 显示 否则: 隐藏 ;

### 引入防抖和节流
正常情况：用户慢慢的划过每个一级菜单，移入事件会被触发，
特殊情况：用户很快的划过一级菜单，移入事件可能不会被触发，通过测试只有部分的h3触发了@mouseenter事件，如果事件回调中有很多业务，就会出现卡顿现象。
### 函数的防抖与节流
节流：在规定的间隔时间范围内不会重复触发回调，只有大于这个时间间隔才会触发回调，把频繁触发变为少量触发。
防抖：前面的所有触发都被取消，最后一次执行在规定时间之后才触发，也就是说如果连续快速的触发 只会执行一次。   
//使用插件lodash.js  里面封装的防抖与节流的业务【闭包+定时器】

```flow js
//防抖：lodash.js接口_.debounce() ，只执行一次（最后一次）回调
let ipt=document.getElementsByName('ipt')[0];
       var res= _.debounce(function(){
            console.log('ajax请求');  //如果有后一个请求，后一个就会替换掉前面的请求，最终只剩最后一个请求生效（规定时间内）
        },2000);
        //获取焦点，内容改变触发事件
        ipt.addEventListener('input',res);
        
        //lodash插件：封装了函数的防抖与节流的业务  防抖（前面所有的触发都取消，保留最后一次）
```

```flow js
//节流lodash.js接口_.throttle()  ，在每个设置的时间间隔内，只执行一次（回调）
//节流：在规定间隔事件范围内不会重复触发回调，只有大于这个时间间隔才会触发回调 （把频繁触发变为小量触发）
var span=document.getElementsByClassName('span')[0];
var btn=document.getElementsByClassName('btn')[0];
//需求：计数器在一秒内数字只能加1（不管点击加了多少次）在每秒内只能加1.  回调函数在1秒内只能执行一次
btn.addEventListener('click',_.throttle(function(){
    span.innerHTML++;
},5000));
//节流：目前事件回调的函数5秒钟执行一次（且只能执行一起），加入函数内有许多业务代码，可以给浏览器更充裕的时间去解析。
//频繁的操作变为少量的操作
```

### 三级联动防节流

注意：methods中函数的this指向问题，methods中不能使用箭头函数，应该使用普通函数，this才可以指向vc或vm

### 三级联动组件的路由跳转与传递参数
如果使用router-link的话，遍历，会有很多的router-link跳转路由，产生卡顿。
所以在这里我们使用编程式路由导航 $route.push  $route.replace ，我们不直接给一二三级跳转标签添加事件，而是利用事件委托，找一个共同的父元素
（编程式路由导航+事件委托）实现路由跳转与传递参数

自定义属性：:data-xxx=""  ,xxx为自定义的属性名
Event.target.dataset;返回一个对象，对象的属性与属性值与 元素的属性和属性值对应
对编程式路由导航push|replace的参数的整理，合并
let local={path:'/'}
let query={name}
如果满足对应的分支几级列表a，对应分支的会把对应的那一级id穿给query对象的id属性，
最后把query对象作为local对象的参数，local.query=query


### 复习
1、三级列表由静态变为动态
、使用axios发送请求，导入axios，创建 axios实例 （配置请求超时的时间，默认路径baseUrl）,配置请求拦截器与响应拦截器（加载进度条），
给axios实例设置请求的路径，以及请求的方式（get|post），=》封装到函数里面return出去axios对象实例，配置代理（解决跨域），配置Vuex（模块化）仓库，在组件中挂载钩子中联系对应组件的小仓库的actions对象的方法（请求数据），通过调用commit方法联系mutations对象，中往state存储请求过来的三级列表的数据，
使用mapState映射拿到对应的三级列表的数据，v-for 每一级列表的渲染数据，动态添加一级列表背景自定义类名，事件委托，防抖节流，使用节流操作，
三级列表数据的传递==》search组件 （涉及到编程式路由导航push|replace 传递query参数?k=v&a=1 传递params参数 在配置路由路径的时候要用占位符）利用的自定义属性  :data-xxx="" 配合e.target.dataset

### search组件的商品分类与过渡动画
利用v-show 控制三级列表的显示与隐藏 要在对应的search组件中  使用this.$route.path判断当前的路由组件是否是search
动画与过渡：使用的前提，必须由v-show或v-if开可以使用
transition标签 定义元素的动画与过度 transition-group标签定义多个元素的过渡与动画

### 商品分类三级列表优化

问题：就是在我们每次切换路由组件的时候，都会使TypeNav组件的挂载钩子触发，就会再次向服务器发送请求（this.$short.dispatch方法联系actions中对应的方法请求数据），影响性能。
在这里我们App根组件只挂载一次，所以我们在App根组件的mounted钩子中发送请求，请求一次数据把服务器数据放到state中存起来就可以了

###合并参数
head组件的搜索按钮 编程式路由导航 跳到search组件 传递参数params（关键字）
home组件的三级列表 每一个a标签 编程式路由导航 跳到search组件 传递query参数（三级列表级别 商品名）
search组件接收（params以及query参数），不管怎么跳转，每个编程式路由导航只配置一个参数类型的话，点了这个会替换另一个（点了三级列表如果只配置一个query的话 传过去以后 ，如果再点击搜索按钮就会把query参数替换，变为传递的params参数）。
要注意的是，传递params参数要使用路由的name名不能使用path。

每一个路由组件都会有一个$route里面存的该组件的路由信息（path name query params）,而在当前时刻只会有一个路由组件被激活url路径中的路由组件路径，当前的$route存的当前激活的路由组件（或者说是显示的路由组件）的路由信息，
**注意：在当前路由组件被激活的这一个时刻，每一个路由组件中的this.$route都指向当前被激活的路由组件（url地址中的路由路径对应的路由组件的$route）**

先点搜索再点三级列表  先传递params参数（Header组件搜索按钮的编程式路由导航 跳转到Search组件） ----->再传递query参数（触发了TypeNav组件中三级列表每一个a的编程式路由导航 ，而里面只配置的query参数传给Search，跳转到Search组件 ）所以Search组件只能够接收query参数，前面传递的params参数? 还是在$route的params属性中存着，只是我们在点击完搜索按钮跳转路由传递params参数以后，又点击了三级列表的路由跳转传递了query参数（现在应该有两个参数params 和query参数）但是我们在三级列表的路由跳转的编程式路由导航的配置中只传递了query参数，应该也给params参数留一个位置（声明一下 如果有的话我也拿过来一起传递过去），为了避免用户先点击了搜素按钮，再点击三级列表。
不管你传什么参数（只要你传了，Search组件就会接收到），但是传过来只传一个（一种）参数，Search就只接收一种的参数

如果不进行参数的合并的话：Search组件最终收到的参数由最后点击路由的调转 传递的参数所决定。

合并路由参数注意：就是在这次路由跳转的时候，我们如果如果在上一次路由跳转也是跳转到当前路由组件（并传递的参数）并且需要用到此参数，在本此路由跳转的时候我们就要把上次传递的参数一起带上，加上这次路由跳转的参数一起传递给跳转的路组件。

### 开发Home首页
轮播图部分：两个组件（Listcontainer和Floor）；
mock（模拟）虚假，用到插件 mock.js数据  ，mock中的数据只能在我们前台转（mock请求会被浏览器拦截，不会真正的往服务器跑）
npm i mockjs 安装mockjs
1.准备JSON数据 （json数据格式一定要格式化一下别留有空格）
2.json文件默认对外暴露（就像图片一样，不需要暴露，直接就可以使用）
3.把mock需要的json图片资源放到public 文件中
4.创建mockServe.js文件模拟数据
5.将mockServe.js文件引入（引入一次），这样它才可以执行。
我们平常引入link引入css 、script引入js文件时是直接引入的，就像引入图片一样直接引入。
在模块化中，我们必须将某个变量，方法，对象暴露出去，才可以引入然后使用（如果直接将整个文件导入的化可能会有命名冲突），模块作用域
node.js（commonJs规范）模块作用域：module.exports暴露 或exports，require("") 导入
js文件中：export （分别暴露 统一暴露）和export default xxx 默认暴露  ，使用import * as xxx from 'xxx.js'  ,import {xx} from 'xx.js',import xx from 'xx.js' 。
mock模拟请求过来的数据。
注意：不管有没有请求拦截器或者是响应拦截器，使用 axios实例发送请求返回一个带有状态的promise对象，promise对象中有请求的数据，我们需要使用.then 和.catch对其进行处理。或使用async与await。🔺

### swiper
基本使用引入css ，js
页面基本骨架
创建Swiper实例（前提页面要有dom元素）

banner轮播图那里v-for必须等数据有了才开始遍历列表渲染。

挂载完毕、调用dispatch联系actions发送请求，（await 等待请求异步任务），执行mounted钩子中的初始化swiper实例（注意这个时候请求异步任务还没开始，反正是没有完成），执行请求异步任务，出来结果，联系mutations修改state数据，Listcontainer组件mapState映射state中的banner数据，v-for拿着banner数据进行列表渲染。
解决方案一：mounted生命周期钩子（确保页面有解构，单数异步请求的数据不能保证 ，v-for不能够执行） 和 使用setTimeout （保证初始化swiper实例在异步请求的数据回来之后，这时v-for就可以拿着数据列表渲染）。
解决方案二：watch监视属性（监视组件映射state中的bannerList数据的变化，请求过来数据就会触发回调，但是不能够保证页面有dom）  和  $nextTick生命周期钩子（在事件循环结束之后调用，当数据发生变化，不会立即生成dom（不然数据不断更新，一直生成dom会有效率问题），而是放到任务队列中，等事件循环中生成dom）在这里面的回调函数中操作更新后的dom。

floor组件的轮播图。
联系actions在哪里联系？数据包含两组对象，在home组件中联系actions请求,
在自定标签（组件标签）使用v-for，把v-for遍历出来的两个floor传给子组件.
在floor组件初始化swiper实例的时候就可以使用mounted，因为floor的请求是在父组件Home中的mounted中联系actions发送的，父组件Home先挂载完毕，联系actions发送请求，然后mutations将请求过来的数据发到state中，Home组件mapState映射数据floorslist，然后将数据传递给子组件floors，
所以子组件在挂载完毕的时候已经有数据了，（就不需要监视属性+$nextTick）
组件间通信：
    1.props （父传子）
    2.props+函数传递（子传父）
    3.自定义事件 $emit $on $off
    4.全局事件总线 
    5.消息订阅与发布
    6.插槽
    7.vuex
------@Home首页路由组件完毕99.99%..

###
如果某一个组件很多地方在用，就像TypeNav三级下拉列表，后面的分页就可以将他封装成全局组件。

### Search组件
静态页面
静态组件
发请求
vuex
组件仓库获取数据，动态展示数据

###search静态路由组件

###发请求 axios+vuex拿数据
在这里Search组件的请求数据的时候，我们要传递参数给服务器，在这里参数至少要传递一个空对象（不然就会出现201状态），在我们的Search组件的小仓库中使用actions对象中的函数调用分别暴露的函数（返回一个axios请求实例）传递一个参数，在组件使用dispatch调用actions中的函数时，传递参数，在actions中的函数设置默认参数，如果没有参数，就使用默认参数空对象，在调用暴露的函数时请求就会生效，使用commit联系mutations并把数据传递过去，
mutations将数据存到state中。
###拿着请求的数据对页面进行动态展示
###根据不同参数获取数据
如果直接在mounted钩子中联系actions发送请求的话，该请求只能够发送一次（所以把联系actions请求放到methods函数中，不管是事件调用，还是mounted中都可以不断被调用）。
向服务器请求所携带的参数，我们放入对象中写在data中（数据就会有getter,setter，有深度监视）
整理请求参数需要在请求之前（mounted钩子中调用联系actions请求的函数），写在mounted钩子之前，在这里放在了beforeMount
服务器会根据我们请求所传递的参数，响应返回对应的数据。
Object.assign(拷贝到的对象obj，被拷贝的对象obj1);
就是将obj1对象中的所有数据以及属性对应的属性值拷贝到obj对象中，（如果obj中有了obj1中的对应的属性--对应的属性值就会被替换为obj1的对应的属性值，如果obj中没有obj1的属性值就会添加k:v）

###复习：Search路由组件进度
请求了接口的数据，向接口传递参数（参数放在data中，用到了Object.assign方法拷贝路由的query和params参数到data参数对象中），动态展示了下面商品，品牌，以及商品属性的数据。
发送请求传递参数给服务器，服务器根据参数查询 返回相应的数据。
问题是：调用联系actions发送请求的函数 还是在mounted钩子中，只能够发一次（服务器返回的数据就一直是这一个，没有变化），可以跟几乎监听路由中参数（query和params参数）的变化，参数一变就是代表要传递新的参数给服务器了（请求时传递），所以就要发送请求了，就要调用联系actions请求的函数（联系actions，调用actions中的相应函数发送请求，传递参数）。
只要$route中的参数一变，被监听到，就发送请求，传递参数。
路由间的参数传递：query和params方式，就是将一个路由组件的数据传递给另一个路由组件（在地址栏中可以显示）
请求传递参数给服务器：请求时在地址栏中带的参数，服务器会根据参数，查询相关数据，返回给我们。
整理请求时传递的参数为什么要整理两次：
beforeMount钩子就是在mounted钩子被调用之前（调用联系actions请求的函数），把路由中的参数放到参数对象中（整理），但是在这里只会被调用一次。
监视属性watch监视路由的变化（参数的变数）路由参数一变就是代表点击了三级列表（query参数），或者搜索按钮（params参数），表示将要发送请求了（并传递参数），在调用联系actions请求的函数之前，我们把路由中的参数拷贝到参数对象当中（整理），immediate开始就被调用（监视属性开启了这个 不使用beforeMount钩子和mounted钩子也可以实现相同的功能）。如果用户一直在Search路由组件这里刷新没有挂载请求数据的话，渲染不上（没有数据）
有小问题：正常情况下我们点击三级列表手机出来手机，再搜索华为出来华为手机。
        而当我们再次点击三级列表的时候再次传递参数，比如点击冰箱（上一次的华为也带过去了），三级列表传递的冰箱与上一次的关键词手机没有任何关系，就搜索不到数据。
（就像这样，点击三级列表冰箱，再搜索华为）

###面包屑部分
用户单击三级列表，面包屑带着点击的对应关键字出现，当用户点击面包屑的x时，面包屑消失，需重新发送请求（拿取消三级列表名称后的数据），地址栏上显示的参数（query）也要消除。【因为点击了面包屑上的x，就要重新修改data中的数据，拿着数据中删除的三级列表名字的数据带给服务器】
事件回调中不需要再次发送请求（调用联系actions请求的函数）
--点击面包屑删除给三级列表搜索选项时，会被watch监视属性监视的$route路由的回调函数执行，发送请求（拿着删除面包屑事件回调中修改的数据参数发送给服务器）
--为什么不需要再次发送请求了，因为我们在使用编程式路由导航消除地址栏中的query参数的同时，把原来$route中的参数也修改的（原本有query参数，我们只传了params参数），然后$route变化了，被监视属性监听到了，发送了请求（拿着数据参数）

params 关键词部分面包屑：修改数据参数，点击完搜索按钮之后清空输入框中的文字。
--在这里使用全局事件总线，search组件点击keyword关键词面包屑的时候，调用自定义事件（在这里不传递参数），告诉Hearder组件一声我这里用户点击面包屑（keyword搜索选项），你应该把输入框也清空一下。（输入框清空时刻，可以是在点击搜索时直接清空）

品牌部分的面包屑：
--子组件传递参数（id，name）使用自定义事件，父组件绑定自定义事件并接收参数，修改参数数据发送请求

### 平台售卖属性部分
给每一个属性绑定点击事件，传递参数给search组件，search组件数据存到数据参数props数组中（push进去）注意这里参数不能够相同可以使用Set，带着参数发送请求，
--拿着props数组v-for进行遍历列表，平台售卖属性面包屑部分，绑定点击事件，传一个当前点击的面包屑的对应的数组元素，使用数组方法删除掉对应的。

### search组件的升序与降序
数据参数中的order
1: 综合,2: 价格 asc: 升序,desc: 降序  
示例: "1:desc" 。
--参数排列方式：
综合1:升序asc
综合1:降序desc
价格2:升序asc
价格2:降序desc
升序还是降序 在这里不需要我们自己计算 ，请求发给服务器，服务器会帮我们计算，返回数据。
--初始值：综合降序。
1.1判断谁应该有类名，根据order中的1（综合）或2（价格）判断
1.2谁应该有箭头 ，根据数据参数order中的1或2判断（当前），谁有类名谁就有箭头
1.3箭头的上下 根据order中的asc 还是desc判断

根据data中数据参数 确定背景颜色（当前点击的order中的1或2判断），确定升序还是降序（上箭头还是下箭头）也是order中的asc或desc判断
点击事件（传参用于判断是点击的综合还是价格），修改data中的数据参数，发请求。

###（重要1）分页器部分

为什么要用分页？ 数据量大（会卡顿），一次展示少量数据，不会卡顿。
很多地方都使用分页器，就可以将分页器封装成一个单独的组件Pagination

###分页器展示
ElementUI有分页组件，我们后台用。
--分页器需要哪些数据？--
1.当前页码 pageNo表示
2.每一页展示多少条数据 pageSize表示
3.知道整个分页器共多少条数据  total表示  --【到这里我们可以知道有多少页】
4.中间连续的页码数 【5|7】因为对称

慢慢调（自己传假的数据），先别和服务器扯上关系。
父组件先传递假的数据给子组件
子组件拿着假的数据测试，好用了之后，在发请求拿数据。
使用插值语法把总数据数，以及总页数渲染上去。
--△连续页码的起始数字，与结束数字 （假定连续的页码数为5，根据当前点击上的页码【中间值】，当前页码减2就是起始的页码，当前页码加2就是结束的页码）
当前页12
10 11 12 13 14

###分页器动态展示
v-for不仅可以遍历数组，对象，字符串，还可以遍历数字。
先写中间连续部分 ，利用v-for遍历一下end数字 ，是1~end，使用start控制一下显示的连续数字
再设置一下前面和后面（第一页 省略号 和 省略号 最后一页），控制一下显示与隐藏
把真实数据传给子组件（分页器组件），配置自定义事件，子组件传数据（当前点击的页数）给父组件，给选中的一个样式
父组件拿着子组件传递过来的当前页数，修改数据参数，发送请求
小问题：在切换其他产品的时候，页码是继承的上一个产品查阅的页码

两种问题：1.总页数小于连续页数 2.基于（1）正常情况下算出的开始页与结束页，会出现负数或0与 大于最大页的情况。计算属性根据当前页计算出开始页与结束页。

###产品详细信息
静态页面
写axios，配置代理
vuex储存数据
拿数据动态展示路由组件

--需要传递参数给商品详情组件
使用params方式传递参数给detail路由组件，在配置路由的时候需要占个位，
在切到detail路由组件时，滚动条会展示底部（应该展示最上面），继承的Search滚动条的位置。
路由的滚动行为
scrollBehavior(to, from, savedPosition) {
// 始终滚动到顶部
return { y: 0 }
},



路由：配置路由k:v   k就是路径，v就是组件
安装插件vue-router  
let router=new VueRouter({
    routes:{
        {
            name:'',
            path:'',//k
            component:组件名,//v
            meta:{},//路由元信息
        }
    }
})创建路由器实例，就是$router,

--<router-link to=""></router-link>标签 激活路由 to属性写要到哪个路由组件  ，在to中也可以传递参数
--<router-view></router-view> 被激活的路由，路由组件显示的位置

--编程式路由导航（适用于任意标签）
--或$router.replace() 没有历史记录
$router.push({
        name（path ，传递params参数必须要用name）:"",
        query:'',
        params:'',
})

--前进后退
$router.base() 后退
$router.forward()  前进
$router.go()  前进或后退任意步数

--<keep-alive></keep-alive>标签 因为路由组件在失活的时候就会被销毁，使用这个标签，指定不被销毁的路由组件（让路由组件在失活时也可以保持挂载），就像输入框，输入信息在失活时不会丢失。
--路由的两个生命周期钩子  可以处理像setInterVal()这种的效率问题
activated(){} 路由组件被激活时调用
deActivated(){}  路由组件失活时调用
--路由守卫
全局前置路由守卫
router.beforeEach((to,from,next)=>{}){//跳转之前
//到哪去 来自哪 控制是否跳转
}
router.afterEach(){
//跳转进去之后
}
--独享路由守卫
写在对应路由的配置项中
beforeEnter(){}
--组件内路由守卫
beforeRouteEnter(){} 控制是否可以进来
beforeRouteLeave(){} 控制是否可以出去
--路由的工作模式
hash模式 /#/ 与history模式 /

🔺逻辑反：! 
!1===1 为false
!1===2 为false 在这里1表示true，!1就是false ，而false===2为false，所以就是false
!(1===2)为true 注意场景是否加括号


###写商品详情请求接口
axios vuex 组件挂载时联系actions发送请求，actions中请求的数据放入state中，组件mapState映射数据

###组件动态展示
小仓库中使用getters简化一下返回过来的数据。
categoryView:Object   //导航路径数据
price:9197            //价格数据
skuInfo:Object        //商品介绍
spuSaleAttrList:Array[2] //商品型号
valuesSkuJson :

###详细商品信息 
【读空数组是undefined，读undefined就会报错】
请求的数据再state中页要给一个初始值，
小仓库计算属性中，请求服务器数据可能还没有回来直接直接读取数据中的某个属性，就是undefined（再读取属性中的某个值，就会报错），所以要给数据中要计算的属性设置一个初始值【还没有读取到的话，就是一个空对象或空数组】，这样在下一次读取对象中的属性的时候就可能是undefined，而不是报错【读了undefined】。
数据传里面也是一样的 一层一层的，通常在计算属性中数值初始值。

### 动态
产品售卖属性切换高亮

使用：点击事件 ，传递参数 ，methods，排他思维

### 商品详情 轮播图
想要修改计算属性中所依赖的数据（数据是父组件传的，请求的数据），不用直接修改计算属性，可以在data中存一个数据，计算属性依赖的数据改为data中对应数据，因为是想要修改计算属性的已改数据，然后依赖的数据我们改为了data中的数据（监视属性监视数据有了，就修改data数据  初始），我们就是直接修改data中的数据就可以了。【就是要利用好data数据】
slidesPerView: 3,//设置同时展示的图个数 swiper
轮播图部分使用：静态，监视属性（监视请求的数据 父组件传递的），$nextTick钩子，确保有结构。
点击轮播图片，兄弟组件（大图）展示使用：全局事件总线$bus，data数据，计算属性，监视属性，mounted钩子，
动态设置class名：data数据（设置初始值 下标），传递index给事件回调函数，点击事件修改data数据

###放大镜

dom
偏移对象 -- offsetLeft offsetTop （元素距离偏移对象的距离没有偏移对象，就找body左侧与顶部的距离），clientWidth  clientHeight  （元素的宽度与高度） ，offsetWidth offsetHeight （元素的宽度与高度）。
事件对象--e.screenX   （距离屏幕） ，e.clientX （距离视口） ，e.pageX （距离页面） ，e.offsetX （距离自身）  ----点击的那个点距离

使用：鼠标移动事件onmousemove，事件对象（不传参数，就不用写$event），e.offsetX e.offsetY ，设置遮罩定位left top（最小与最大 不能超过父元素的左右边框，上下边框）超过就让他等于那个值 判断最大（根据遮罩宽高等于父元素宽高一半），ref选中元素（或组件），设置big图固定格式，-2*left+'px' 

### 详情页加入购物车 购买商品个数
输入框 用户输入购买个数
使用正则判断，/d匹配0-9 配合+长度 >=1 ,边界符^$  ，v-model双向绑定 ，data数据 ，点击事件

###加入购物车 （修改某个商品个数）（重要）
点击加入购物车 路由跳转 （发请求传递参数 商品型号 购买数量 商品）

当加入购物车，要通知后台（服务器存储一下）

--点击加入购物车要进行路由跳转，之前要发请求传递参数【服务器响应成功】。

1.发请求带参数 通知服务器加入购物车的产品是谁
2.根据请求的状态，成功进行路由跳转，否则就告诉用户服务器未响应。
3.路由跳转（将商品详细信息带过去）

axios ，vuex ，分别暴露 ，async await 返回promise，本地储存 ，JSON.stringify() JSON.parse() 

###查看商品详情（购物车页面）
路由传参时 ，path:'/detail:id?' ,加了? 参数就是可以传可以不传，不加?参数可选的话，不传这个参数，传了其他参数就会跳转有误。
<router-link :to="`/detail/?skuId=${xxx}`"></router-link> ---不加?，这样太跳转传参就会有误

传递params参数 ，因为detail组件挂载联系actions发请求，所传递的参数就是params参数id
这里参数不能传错了，不然跳转过去detail组件挂载的时候联系actions发请求，传的错误的id，服务器就会响应出错误的详情页

使用：router-link to属性 ，传递参数 ，v-bind
###购物车结算   
静态组件
配置路由
router-link to属性跳转路由路径

写接口 vuex ，发请求传参数（这里不用待参数） ，拿数据 展示数据 ，

----组件中联系actions请求 要用很多次 ，就把他封装成一个函数 在methods中。
----在用户点击去购物车结算的时候 ，要告诉服务器用户是谁【不然服务器不是到是哪个用户把商品加入到了购物车】。不知道要的是谁的数据。
    两个身份【游客身份 ，登陆后的用户身份】，在这里我们点击去购物车结算发请求，服务器不知道是谁，返回了空数据。
----使用uuid唯一标识 
----要把id也传给服务器，在哪传？ ，请求头中【请求报文】，在请求拦截器中设置请求头 【发请求 ，请求拦截器设置亲求头传递id（每个用户都是使用的不同的并且唯一的一个），要存到本地储存的中，下次用的时候接直接拿】   
【想法：调用uuid生成id放到本地存储当中，本地存储.getItem('uuid') ? '' : 本地存储.get('uuid',uuid())】
----state中存一个，本地存储存一个。【最终要带给服务器】
----请求头字段【userTempId】  设置请求头config.header.字段=uuid;

tools工具文件夹中的uuid_.js暴露一个生成uuid的函数【本地存储中存一份，detail小仓库中state中存一份（调用函数返回）】
使用：axios请求，vuex，methods封装一个联系actions请求函数，uuid ，本地储存，请求拦截器中设置请求头【传递给服务器字段（参数/数据）】
【用户在商品详情页点击加入购物车时，要样服务器知道你是谁（uuid身份标识），用户在添加到购物车成功页面点击去购物车结算，服务器会根据uuid用户身份标识找到你（和你在服务器存的购物车商品），返回给你商品数据】
### 动态展示数据
拿着用户（游客）商品详情页点击加入购物车的请求（带给服务器的参数，那时不会返回数据）响应头传递一个uuid（用户身份标识）给服务器，在加入购物车成功页面【点击去购物车结算发的请求 这时服务器已经收到商品id 以及商品数量 请求头中收到uuid】 ，就会返回数据。

购物车数据CartInfoList
数据格式有些不完美
[
    {
        time:xxx,
        CartInfoList:[
            {},
            {},
        ],   
    },
]
``` js
    [][0].cartInfoList
    VM1575:1 Uncaught TypeError: Cannot read properties of undefined (reading 'cartInfoList')
    at
 //就像这样就会报同样的错误
```
【处理数据】：因为请求属于异步，服务器返回数据不会一下返回过来，在我们使用数据的地方有可能读取不到数据， 就比如 cartliat数据还没有来，就是undefined，读取undefined就会报错，所以我们要给cartlist设置一个默认值 [],这样数据如果没有来的话，就不是undefined 而是 []空数组，读取空数组【就不会像读取undefined那样报错】，而是一个undefined【不报错】。
【处理复杂数据】：在小仓库的计算属性中处理，可以接着处理的数据处理【也可以在组件中再接着处理小仓库中处理的数据】。

处理好数据进行行渲染页面。
使用：使用计算属性简化数据 ，mapState mapGetters映射数据，v-for ，多选框checked属性，forEach ，数组every()方法 所有数组元素满足条件才返回true，有一个不满足条件就返回false。 


###处理产品数量

用到Detail组件中的一个请求接口 传递商品id 以及数量给服务器。  让服务器数据库记录一下

我们直接修改请求数据的话，舒心页面数据还是原来的，所以在这里就需要发送请求，传给服务器id 与数量。

传给服务器的参数：skuID 与 skuNum  正数代表添加，负数代表减少
购物车商品数量：要传每次加或减的个数，而不是传一个商品的总个数【当前商品数量】
              要拿到输入框前后的数据，取差值【增加或减少的数量】传给服务器 ，服务器会根据所传递的增加或减少的个数在数据库中基于以前的进行累加。

使用一个回调：传递三个参数【点击的哪一个，传给服务器地值（变化的大小），商品id】 ，先发请求传参数给服务器，然后在使用获取购物车数据的请求，获取最新数据。【注意商品数量不能出现负数 ，特殊字符（非数字）】
###商品选中状态
商品选中按钮：点击事件，修改元素，取反操作【点击的时候是1 isChecked就变为0，反之】
            在这里使用一个接口，发请求，把商品id以及商品选中状态发给服务器，服务器不会返回数据【服务器会把数据距离到数据库中】
我们修改商品选中还在那柜台，当我们刷新页面的时候，数据不会丢失，因为我们把选中状态已经发送给服务器存储在数据库当中【就不需要重复调用ShopCart组件的数据请求拿数据了，因为当刷新时，组件会再次挂载，调用methods中我们封装的对应联系actions请求的函数】。
选中商品个数：使用数组方法filter() 对数组元素进行判断，因为选中就是isCheck=1 ,利用这个条件作为满足条件。
--事件对象的target【触发事件的元素】的checked属性返回一个布尔值。点击会把当前的选中状态传递给服务器。
--使用try与catch捕获异常的话，就不要把联系actions请求封装成一个函数了【就直接dispatch联系actions请求就可以了】，不然捕获不到异常。
--每次参数传递给服务器后【服务器操作数据库处理】，再调用另一个联系actions发请求的函数拿最新的数据

购物车商品删除：发请求传递参数给服务器，服务器会处理数据库中的数据，不会返回数据，点击对应购物车商品删除按钮之后 url路径会变成none

【购物车这里：把数据传给服务器（数据库更新数据），再次请求拿最新数据】

###删除选中的全部商品
没有一次删除多个的接口，使用以前一次删除一个商品的接口传参。
我们在小仓库dispatch中使用了一个新的删除全部商品的函数，在此函数中写逻辑【可以拿到store对象 ，解构对象，拿到dispatch（联系本仓库中的actions一次只删除一个商品的函数 请求 传参）与getters（拿到处理后的数据）】
--通过getters中的数据forEach循环过滤出选中状态的商品，拿着这些选中状态的商品的id通过dispatch联系本仓库函数【删除一个商品的请求函数 返回成功或失败的promise对象】。
--使用Promise.all(),实参是一个数组，数组中放的是promise对象【dispatch联系返回的】，有一个是失败的状态整个函数就返回失败的promise对象，所有的请求传参都成功，整个函数就返回成功的promise对象
--在组件对应事件回调中，dispatch联系actions删除全部选中的商品函数 【函数返回一个带有状态的promise对象】
--使用await等待所有完成 请求获取最新数据【另外一个联系actions请求拿数据的函数】
--try catch 捕获错误

###全选按钮
在这里没有一次全选或取消全选的接口，我们还是使用修改商品的选中状态的接口。

async function fn(){
    return await 'ok';
} 
或
async function fn1(){
    return 'ok';
}
--以上两种情况都会返回一个成功的promise对象，并且该promise对象所携带的参数就是async函数所返回的普通数据类型的数据
--【async函数返回普通数据类型数据时，调用函数会返回一个成功的promise对象】【async函数返回一个promise对象的时候，调用函数根据promise对象的状态，返回成功或失败的promise对象】

第一种方法：根据全选按钮状态，只改满足修改条件的商品状态 【全选为true，只改商品为0状态的】
第二种方法：根据全选按钮状态，直接改所有商品的状态
使用：事件对象，解构赋值（actions对象的一个函数中解构store，拿dispatch与getters），Promise.all() 里面放一个数据，数组的元素为peomise对象，所有promise对象状态都是成功就是成功，有一个元素promise对象是失败Promise.all()就返回失败。
--小仓库actions中函数dispatch联系本actions的里一个函数。


###注册与登录（重要）与git

assets文件夹：放置全部组件公用的静态资源【不能删】
@就是src的别名
给用户手机推送短信验证码是后台做的

###注册部分
获取验证码：请求 将输入的手机号发送给服务器，服务器会返回验证码【正常情况下是后台以短信的形式发送给对应手机号上】
注册与登录使用一个小仓库。
获取用户输入手机号，双向绑定 v-model
拿着表单流向data中的手机号进行正则校验【符不符合基本标准】 /^[\d]{11}$/  ,在这里手机号验证是否符合条件是后台验证的，我们只需要发送手机号给服务器【服务器根据手机号的校验返回成功与失败数据 code等于200就是成功】
--禁用 e.target.disabled=true
--配置请求axios 传递手机号给服务器  --vuex 传参（手机号码）给axios实例url   -- 注册组件内 点击按钮 联系actions发请求 传入收集号码
【收集表单数据 放入data中】

表单信息收集
--写axios请求接口配置，使用data传递数据【对象】
--请求路径上的api3 走代理'/api3'
--模块化 export分别暴露
--小仓库中async函数 使用await等待请求传参出结果 拿到promise对象中的数据（请求服务器返回的）
--根据返回的结果状态 async函数返回一个成功或失败的promise对象到dispatch联系此函数的地方
--收集表单的数据data===vc._data 会放在数据代理vc上 ，所以直接解构赋值this（vc），拿对应的表单数据
--使用try 与catch捕获dispatch联系actions中的请求async函数返回的成功与失败的promise 
    Promise.reject(new Error(''));//是一个失败状态的promise对象，并且会抛出一个错误err
    成功【没有捕获到错误（服务器将用户注册信息存入数据库中）】，进行路由跳转

【先写业务，后面再表单的验证】
###登录 
已经注册成功的用户信息【账号密码】传入服务器后会被存入数据库中。
登录时，发请求把账号和密码传给服务器，服务器拿着账号与密码到数据库查询比对，如果一致的话进行下一步【看具体要干什么】

【收集用户名与密码】
【点击登录按钮发请求】

--请求方式要正确 这里是post方式【写错的话就是201 错误了】
--所传递的参数要与接口文档参数名称要一致【不一致的话会返回202 参数不正确】
--别忘走代理 这里走的是api3代理 解决跨域
--成功的话，服务器会返回数据【包括token字符串令牌】

【请求路径错了会报错，返回失败的promise对象】
【请求方式写错了，不会报错，但会返回201 错误】
【请求成功了，用户信息有误，会根据信息的错误类型返回相应数据以及状态码】

【登陆业务】
----【token服务器返回的，用户身份唯一标识】（就像身份证）
----【一般情况下登录后，只会返回一个token令牌】
----【我们登陆后就是拿着token令牌到服务器要数据】

【注意】vuex存储数据不是持久化的，存的数据一刷新就没了   △△△△△△△ 
------vuex中的数据是存在内存中的，在路由组件中刷新时【挂载发请求】，如果没有再次发请求拿数据放进去，数据有没有了

###登录以后 用户信息展示
     登录成功，路由跳转到home
--当home组件挂载的时候发请求，拿登录后的用户信息 
【要在请求拦截器中配置请求头token字段（有就传--有就表示用户登录了服务器返回了token ，没有就不传--没有表示用户没有登录本地储存没有token令牌就是用户未登录的状态)】
  配置axios实例 ，并导出函数
  注册与登录小仓库中导入请求函数，actions配置async函数调用请求函数
  await等待请求出结果，根据状态async函数返回相应的成功【联系mutations，并把请求过来的用户信息数据传递过去】与失败的promise对象
  mutations把数据放到state中
--Header组件，根据用户信息数据name的有无【name用户数据的有无，取决于是否向对应获取用户信息的接口发请求，请求头带上token】，决定（登录|注册）与（用户名|退出登录）的显示与隐藏【如果有用户登录后的用户信息数据中name，表示用户已经登录，就需要展示（用户名|退出登录）】，这里使用了v-if="!userName" 【有了就是true，我们给他取反让（登录|注册）隐藏】，与v-else

用户登录之后服务器就会返回token
全局组件Header中的登录与注册 、用户名与退出登录的是否渲染【取决于用户信息有无】
用户信息有无【取决于是否向对应获取用户信息接口发请求，并携带token请求头到服务器进行校验用户身份】
问题1、登录后，在Home首页刷新，Header数据【用户名】不会丢失，在其他路由组件刷新，Header中的已登陆的用户名数据会丢失？
        （1）因为我们只在Home组件挂载的时候发请求【带上token请求头到服务器校验】，然后服务器返回用户数据到注册与登录小仓库中【Header组件用户名的显示就是取决于小仓库中的用户数据】，我们Home组件每次挂载就会发请求【有token的话】就会拿到用户数据，去他组件没有在挂载的时候，发请求，拿用户数据。【可以挨个路由组件在mounted钩子中发请求拿用户数据--每个都要写一次】
        （2）可以在App组件挂载的时候发请求【App组件只会挂载一次】，缺点：一上来没有，刷新后才有


###退出登录
--【退出登录】：发请求，告诉服务器要退出登录【服务器会删除对应的token】，删除本地存储中的token，清空注册与登录组件小仓库中的用户信息 ，路由跳转到首页。
    退出登录以后对应服务器返回的token就会作废【无效化】，退出登录，服务器要删除对应的token【防止用户拿着之前的token再次登录】
//我们先不删除本地储存中的token，只是联系服务器要退出登录，服务器删除了我们请求头中的对应token，我们Home组件在挂载的时候还是发请求拿用户登录
// 信息【本地存储中有token】带的token字段的请求头，但是由于服务器已经删除了这个token令牌【也就是说我们传递的是一个已经无效的token，服务器找不到此token】， 所以就不会返回用户信息数据【Header组件就显示 登录 | 注册】
--如果只清除本地储存的token与注册登录小仓库中的用户数据信息，没有发请求联系服务器要退出登录【如果用户退出后（提前复制的token）放到本地存储中，刷新挂载发请求带上token字段请求头，拿用户数据信息，服务器还是会校验成功的】

###路由守卫
--用户登录以后【就不能登录了--不能够出现登录界面--用户在url地址输入login不能让他跳到登录界面】
判断用户是否登录【token】
判断用户是否要跳到注册与登录组件【to参数】
去除了注册与登录组件之外的其他组件【判断仓库是否有用户信息】 ，有就放行，没有就请求拿用户数据信息【Header组件的展示】
根据请求获取用户信息actions中对应函数返回的状态，使用try catch捕获，未能捕获到错误【请求用户数据信息成功 放行】，捕获到错误【token过期..】删除本地存储中的token以及用户数据信息，放行到登录组件。 
--用户没有登录，就不能跳转到购物车。

路由守卫的第三个参数next【放行】
next(false): 取消当前的导航。如果浏览器的 URL 改变了(可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到 from 路由对应的地址。
next('/home')一个路由地址: 通过一个路由地址跳转到一个不同的地址，就像你调用 router.push() 一样

###交易页面 路由组件
【收件人地址信息】接口 200状态码，返回不了数据，我们自己mock
【用户商品清单】接口 使用老师的账号有数据

写axios，vuex【集中式状态管理】存数据，组件挂载联系actions发请求。
动态展示数据，用户收货地址，默认地址，右下角展示【默认收货地址】

展示订单信息数据【购物商品清单】   服务器返回数据中的detailArrayList

### 提交订单
在这里发请求我们就先不使用vuex，直接在组件内发请求存数据。
如何导入接口请求函数？
（1）import {xxx,xxx} from '@/api';//这样一个一个导入
``` js
（2）利用vc.__proto__.__proto__===Vue.prototype
    一次引入全部的
    把所有的接口请求函数放到Vue实例对象身上
   Vue.prototype.$Api=api
   ```
点击提交订单，发请求传参数【订单编号】【用户名，电话，地址，支付方式，留言，购物请求的数组】 请求头要有token

成功路由跳到付款界面   
----ShopCart路由组件中，点击【结算】【只是来了一个路由跳转】到Trade路由组件。
---Trade路由组件一挂载完成，就发请求，拿【用户收货地址信息 mock出来的 请求网络中不会展示】【用户购物商品清单】渲染。
--Trade路由组件中，点击【提交订单】按钮会把【订单编号】--是在用户购物清单对应请求返回过来的数据带的  ，以及【名字，电话，地址，支付方式，留言，用户购物清单数据数组的形式】发送给服务器，成功后服务器返回【订单号】，存起来，路由跳转到支付界面 要传参【支付界面要用到】。

###支付界面

发请求【带上Trade组件路由跳转过来Pay组件时，所带的query参数（订单号）--点击提交订单按钮后发请求返回的】，渲染支付页面总金额，会返回支付二维码【生成】。
支付：
--点击弹出二维码 使用element-ui遮罩层（弹窗）
--支付成功跳转
（1）引入element-ui 
 按需引入  
  npm i element-ui
  npm install babel-plugin-component -D
  配置bable.config.js文件
  引入import {Button} from 'elememt-ui'
  注册对应要使用的el组件 Vue.component(组件名，Button);

--使用弹窗组件
import {MessageBox} from 'element-ui';
Vue.prototype.$alert=MessageBox.alert;
<el-button type="text" class="btn" @click="open">立即支付</el-button>
使用组件，每个组件都有对应的参考配置。

###微信支付业务
根据Pay组件挂载发请求，返回的数据中的  payInfo.codeUrl ，生成支付二维码【qrcode】--会将服务器返回的二维码字符串生成二维码。
QRcode.toDataURL(this.payInfo.codeUrl);//返回一个带有状态的promise对象【带有二维码】
用户点击支付，弹窗二维码准备支付的时候【服务器知道支付状态】，要不断发请求询问服务器用户的支付状态【轮询--及时根据支付状态切到支付成功界面】
--点击立即支付，触发回调，弹出弹窗，【我们需要知道用户的支付状态】，开启定时器不断发请求【询问服务器用户支付状态】，根据返回的数据code状态码，200时，服务器就把用户支付成功的消息返回过来【用户支付成功】。
--在这里当支付成功后，我们不能忘记清除定时器【不发请求】，存一个状态码【以后用户点击我已支付按钮 依据】，隐藏弹窗 路由跳转。

处理两个按钮【支付遇到问题】【我已支付】：点击任意一个按钮，不能直接关闭弹窗【写业务】，查看对应组件配置属性
参考element组件的配置属性
beforeClose(type,elVc,done){}
//type：返回用户点击的那个按钮  cancel用户点击支付遇到问题 ，  confirm用户点击我已支付
//elVc：element-ui组件实例
//done：关闭弹窗
--首先根据type判断用户点击了哪个按钮
--如果type 为cancel用户点击支付遇到问题 ：弹出提示框提示用户，清除定时器【停止发请求】，关闭弹窗
--如果type 为confirm用户点击我已支付 ：这是就需要知道用户是否支付成功，因为我们不断发请求，询问服务器用户是否支付成功，如果用户支付成功，存到data中的状态码就派上了用场【就是根据这个判断】，如果data中的状态码为200【表示用户支付成功】，清除定时器【停止发请求】，关闭弹窗，路由跳转


### 个人中心路由组件（二级路由）
先注册一级路由组件（个人中心）
 个人中心路由组件中：我的订单与团购订单【二级路由组件】  
个人中心一上来展示我的订单【重定向】  
``` js
     //重定向我的订单二级路由组件
                {
                    path:'/center',//二级路由重定向 这里写对应的一级路由的路由路径
                    redirect:'/center/myorder',
                }
```

获取我的订单列表【个人中心】数据展示
--动态合并列【根据商品数量】
--分页器【组件间通信，子传父数据】，给子组件绑定自定义事件【@自定义事件="回调实参接收子组件传递过来的数据"】【this.$refs.标记的子组件.$on('自定义事件',回调实参接收子组件传递过来的数据)】


###路由守卫 未登录部分
未登录 不允许用户去：交易页【trade】 ，支付页【pay ,paysuccess】 ，个人中心【center】
用户未登录，根据to参数的path地址，判断是否有以上路径，有就跳转到登陆页，让用户进行登陆，其他符合条件的就放行。
用户登陆完，还需要跳回要去的地方 ，怎么做？ next('login')的时候顺便传一个参数【用户要to的path】，我们在login页组件，登陆成功时要进行路由跳转，根据路由有没有query参数wanto要去的地方，有就往那里条，没有默认跳到首页。

### 独享路由守卫
在路由配置项中使用beforeEnter(to,from,next){}
用户去交易页【必须从购物车去】
用户去支付界面【只能从交易页去】
用户去支付成功界面【只能从pay页面去】

###图片懒加载
vue-lazyload 插件

自定义插件：
我们在 Vue.use(插件名,{name:pload});使用插件的时候，就会自动调用插件中的install方法【可以接收两个参数Vue，使用时后面的参数 】

图片懒加载插件的使用：
```flow js

//npm i vue-lazyload@1.3.3 -S    高版本会报错
//导入懒加载插件
import VueLazyload from "vue-lazyload";
//导入图片加载
import loadimg from  '@/assets/loading.gif';
//使用图片懒加载插件
Vue.use(VueLazyload,{ //Vue.use()一调用，实质是调用插件install方法
loading:loadimg,
});

在展示图片的地方使用v-lazy自定义指令
```

在Vue.use()使用插件时，实质上就是调用了插件的install方法【会接收vue参数，以及使用插件时，传入的第二个配置对象】，可以在自定义插件中【install中】配置自定义指令，过滤器..

###表单验证
vee-validate插件
或使用element-ui的表单验证
在这里我使用的最喽的认证方式【正则加表单change事件】
###路由懒加载【高效】
当打包构建应用时，javascript的包会变得非常的大，影响页面加载。
如果我们能把不同的路由组件分割成不同的代码块，然后路由被访问时才加载对应组件，这样就更加高效了。
const Home=()=>import('@/pages/Home/Home.vue');//返回promise对象 动态引入路由组件【按需加载】
或者路由配置项中
{
    path:'/home',
    name:'home',
    component:()=>import('@/pages/Home/Home.vue'),//这样动态引入路由组件
}
就不用import Home from '@/pages/Home/Home.vue';//这样引入路由组件了


###项目打包 上线
npm run build

打包后有.map文件，项目打包后，代码都是经过压缩加密的，如果运行时报错，输出的错误信息无法准确得知是哪里的代码报错。
有了map文件就可以像未加密的代码一样准确输出是哪一行有错。

打包如果不需要map文件，可以在vue.config.js配置文件中 加上productionSourceMap:false

### 服务器购买
腾讯云 阿里云
### 安全组
服务器端口对外开放
###nginx反向代理
高性能http与反向代理web服务器
帮我们买的服务器向 请求数据的服务器要数据
--nginx配置
1、进入/etc目录，这个目录下的nginx目录，
2、yum install nginx
3、安装完以后们就会多一个文件nginx.conf文件
4、编辑此文件，vim
编辑一、
   location / {
        root   /root/lyw/www/shangpinhui/dist;
        index  index.html;
        try_files $uri $uri/ /index.html;
    }
编辑二、
    location /api {
        proxy_pass http://gmall-h5-api.atguigu.cn
    }
5、service nginx start  //nginx服务器跑起来


###回顾组件通信方式
1、props 父传子数据
 子组件props:['totals']接收数据 ，要优先于data，{totals:Number}设置类型，{type:Number,default:true}
当父组件传一个函数过来，，就可以利用props实现子传父数据。
2、自定义事件 子传父数据
父组件$on绑定自定义事件【给子组件使用$refs标记的子组件】后面回调函数参数接收子组件传递的数据，$emit调用自定义事件
<Zizujian @hello="getZtext()"></Zizujian>
<Zizujian ref="zzj"></Zizujian>
export default{
    name:'fuzujian',
    methods:{
        getZtext(ztext){
            console.log(ztext);//就会打印出'子组件要传的数据'
        }
    },
    mounted(){
        this.$refs.zzj.$on('hello1',(ztext)=>{});//亦可以以这种方式在父组件中给子组件绑定自定义事件。
    }
}

子组件中
<button @click="sendFuzujian()">传数据给父组件</button>
export default{
    name:'Zizujian',
    methods:{
        sendFuzujian(){
            this.$emit('hello','子组件要传的数据')
        }
    }
}

3、全局事件总线   任意组件传数据
main.js实例vm配置对象中 beforeCreate(){}钩子中Vue.prototype.$bus=this;
接收数据【绑定自定义事件this.$bus.$on()】  ，传递数据【this.$bus.$emit()】
4、pubsub【消息订阅与发布】 任意组件传递数据
插件
5、vuex 【集中式状态管理】
actions【发请求 拿数据 将数据传给mutations对应函数】 mutations【借数据放入state】 state【存数据】 getters【简化数据】

模块化 命名空间

对每个对象的操作
mapState mapGetters映射数据     mapActions mapMutations   映射方法

6、插槽
默认插槽 具名插槽 作用域插槽
在使用组件的地方 <Hello>在这个Hello组件中要插入内用</Hello>  ，对于这个组件内的角度，不确定内容插到哪里就使用<slot></slot>规定给融插到哪
使用组件的地方，组件中要插入内容，使用slot属性设置插槽名 ，<slot name="插槽名"></slot>
slot-scope属性接收传的数据使用组件的地方，<Hello>组件内<templat slot-scope="ztext">插入的标签内容</template></Hello>  ，要插入的内容使用此属性  。组件中<slot :ztext="ztext"></slot>

插件的使用【第三方库】
vuex注意版本 ，vue-router注意版本 ，请求加载进度条【nprogress】 ，防抖节流插件【lodash】，mockjs ，swiper插件 ，第三方过渡与动画的css库 ， UUID ，支付字符串转二维码插件【qrcode】 ，图片懒加载插件【vue-lazyload】 ，less的css类型 ，element-ui .


### 
【事件】
普通元素：一般绑定普通事件
组件元素：绑定自定义事件【传数据】
自定义事件接收子组件传递过来的数据【简写：@zidingyi="msg=$evevt"】
【v-model双向绑定原理】
核心利用 v-bind单向绑定 和 input事件【获取焦点并且内容改变】
--组件自定义事件写成input是固定写法【不然后面组件直接使用v-model不起作用】

【组件通信 属性sync修饰符】
实现父子组件数据同步
--这里组件自定义事件使用 update:money="" ，是固定的【针对于传的数据名】，不然组件使用属性sync修饰符不起作用【不使用sync修饰符的组件没有影响--可以不按照固定写法】
    <Zizujian1 :money.sync="money"></Zizujian1>  //当sync与v-bind 一起使用后面不能写表达式，只能写属性名
    <h5>子组件Zizujian1</h5>  <!--可以不和父组件自定义事件名一样，但必须这样写【固定格式】想要使用sync属性修饰符的话-->
    <p>每次花100块<button @click="$emit('update:money',money-100)">花100</button>父组件还剩下{{ money }}</p>

【组件通信 $attrs与$listeners】
组件库组件的二次开发，【动态】

$attrs ：子组件中接收父组件在使用的子组件上绑定的属性【传的数据】 由于传递的属性可能非常多 可以【v-bind="$attrs"】，如果子组件使用props接收了，那么$attrs就不会再有了。
$listeners：子组件接收父组件在子组件上绑定的自定义事件【子组件使用v-on调用 ----  v-on="$listeners"】

【$children与$parent】
在父组件中，使用ref可以获取的子组件实例，进而就可以操作子组件的数据。
$children：获取当前组件的所有子组件【放在数组中】【不能确定对应的位置就是你想要的那个组件】进而操作所有子组件的数据
$parent：获取子组件的父组件【当前组件的父组件】就可以操作父组件的数据与方法

【作用域插槽】
因为组件复用，不能够直接在组件内修改它结构【使用组件的时候，利用插槽，对其结构进行修改】

子组件的数据是父组件给的，子组件决定不了外观【遍历把每一条传给父组件，父组件 v-slot接收 或 slot-scope接收】

###问题： //用户未登录，点击要到的地方【个人中心】，会先跳到登陆页面让用户登陆【之后跳到用户要去的地方】问题：要点击两次登陆

【第一次点击不能进】
用户未登录，要去个人中心，跳转到登录页面，当用户点击登陆的时候会发请求向服务器验证返回token【这里我把返回的token写在路由跳转的后面】，常理来说用户点击登录服务器校验成功以后，就会跳到用户要去的那个页面，路由跳转【这里登录拿到token----还没储存在本地，全局路由守卫那里拿不到token，走的是未登录的守卫部分】，然后将token存起来了【本地存储中】
这时【第二次点击可以进】再次点击登录按钮，发请求服务器校验返回token，然后要路由跳转，【这时有token全局前置路由守卫可以走登录部分--利用上一次的token进入的】，但是还没有用户数据，没有直接过去【发请求拿用户数据】再进去。【问题来了，为什么路由守卫进来的是凭借上一次点击登录按钮服务器返回的token进的，而进来没有用户数据发请求拿用户数据 请求头中的token是最新，在发请求（异步）拿用户数据的时候已经把token存入在本地存储中】

注意：用户登录成功【服务器返回token存入本地的时机】